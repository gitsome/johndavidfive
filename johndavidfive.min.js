"use strict";var plaidUniforms=THREE.UniformsUtils.clone(THREE.ShaderLib.phong.uniforms);plaidUniforms.shininess.value=60,plaidUniforms.diffuse.value.setHex(16777215),plaidUniforms.specular.value.setHex(6710886),plaidUniforms.verticalOffset={value:0},THREE.ShaderLib.plaid={uniforms:plaidUniforms,vertexShader:['\n\n        #define PHONG\n\n        varying vec3 vViewPosition;\n        varying vec2 vUv;\n\n        #ifndef FLAT_SHADED\n\n            varying vec3 vNormal;\n\n        #endif\n\n        #include <common>\n        #include <uv_pars_vertex>\n        #include <uv2_pars_vertex>\n        #include <displacementmap_pars_vertex>\n        #include <envmap_pars_vertex>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <morphtarget_pars_vertex>\n        #include <skinning_pars_vertex>\n        #include <shadowmap_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n\n            vUv = uv; // CUSTOMIZATION: This is how we get access to vUv without enabling a "map" in the define section of the shader\n\n            #include <uv_vertex>\n            #include <uv2_vertex>\n            #include <color_vertex>\n\n            #include <beginnormal_vertex>\n            #include <morphnormal_vertex>\n            #include <skinbase_vertex>\n            #include <skinnormal_vertex>\n            #include <defaultnormal_vertex>\n\n        #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n            vNormal = normalize( transformedNormal );\n\n        #endif\n\n            #include <begin_vertex>\n            #include <morphtarget_vertex>\n            #include <skinning_vertex>\n            #include <displacementmap_vertex>\n            #include <project_vertex>\n            #include <logdepthbuf_vertex>\n            #include <clipping_planes_vertex>\n\n            vViewPosition = - mvPosition.xyz;\n\n            #include <worldpos_vertex>\n            #include <envmap_vertex>\n            #include <shadowmap_vertex>\n            #include <fog_vertex>\n\n        }\n\n    '].join(),fragmentShader:['\n\n        #define PHONG\n\n        uniform vec3 diffuse;\n        uniform vec3 emissive;\n        uniform vec3 specular;\n        uniform float shininess;\n        uniform float opacity;\n        uniform float verticalOffset;\n\n        varying vec2 vUv; // CUSTOMIZATION: This is how we get access to vUv without enabling a "map" in the define section of the shader\n\n        #include <common>\n        #include <packing>\n        #include <dithering_pars_fragment>\n        #include <color_pars_fragment>\n        #include <uv_pars_fragment>\n        #include <uv2_pars_fragment>\n        #include <map_pars_fragment>\n        #include <alphamap_pars_fragment>\n        #include <aomap_pars_fragment>\n        #include <lightmap_pars_fragment>\n        #include <emissivemap_pars_fragment>\n        #include <envmap_pars_fragment>\n        #include <gradientmap_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <bsdfs>\n        #include <lights_pars>\n        #include <lights_phong_pars_fragment>\n        #include <shadowmap_pars_fragment>\n        #include <bumpmap_pars_fragment>\n        #include <normalmap_pars_fragment>\n        #include <specularmap_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        // plaid constants\n        const float plaidSquare = 1.0 / 9.0;\n        const float plaidSpacer = plaidSquare * plaidSquare;\n        const float plaidBar = (plaidSquare - 2.0 * plaidSpacer) / 3.0;\n\n        // plaid stop points\n        const float plaidStop1 = plaidSquare;                   // main\n\n        const float plaidStop2 = 2.0 * plaidSquare;             // empty\n\n        const float plaidStop3 = 3.0 * plaidSquare - plaidBar;  // main\n        const float plaidStop4 = 3.0 * plaidSquare;             // alt\n\n        const float plaidStop5 = 4.0 * plaidSquare;             // main\n\n        const float plaidStop6 = plaidStop5 + plaidBar;         // alt\n        const float plaidStop7 = plaidStop6 + plaidSpacer;      // main\n        const float plaidStop8 = plaidStop7 + plaidBar;         // alt\n        const float plaidStop9 = plaidStop8 + plaidSpacer;      // main\n        const float plaidStop10 = plaidStop9 + plaidBar;        // alt\n\n        const float plaidStop11 = plaidStop10 + plaidSquare;    // main\n\n        const float plaidStop12 = plaidSquare * 9.0;            // empty\n\n        // our main plaid colors\n        vec4 mainColor = vec4(0.0, 0.0, 0.0, 0.5);\n        vec4 altColor = vec4(0.0, 1.0, 0.56471, 0.5);\n        vec4 emptyColor = vec4(1.0, 1.0, 1.0, 0.5);\n\n        // method that takes a percentage of the plaid pattern and returns the proper color\n        // this logic is used in both directions. it is this logic that determines the plaid pattern\n        vec4 getPlaidColor (float percent) {\n\n            // the large majority will be blank so start with that scenario\n            if (percent > plaidStop11) {\n                return emptyColor;\n            } else if (percent <= plaidStop1) {\n                return mainColor;\n            } else if (percent <= plaidStop2) {\n                return emptyColor;\n            } else if (percent <= plaidStop3) {\n                return mainColor;\n            } else if (percent <= plaidStop4) {\n                return altColor;\n            } else if (percent <= plaidStop5) {\n                return mainColor;\n            } else if (percent <= plaidStop6) {\n                return altColor;\n            } else if (percent <= plaidStop7) {\n                return mainColor;\n            } else if (percent <= plaidStop8) {\n                return altColor;\n            } else if (percent <= plaidStop9) {\n                return mainColor;\n            } else if (percent <= plaidStop10) {\n                return altColor;\n            } else { // save a little time by not checking, this is the last possible case\n                return mainColor;\n            }\n        }\n\n        // distance from line one (slopes down and to the right)\n        const float slopeOne = 1.0;\n        const float yIntOne = 1.0;\n        const float denomOne = sqrt(slopeOne * slopeOne + 1.0);\n        float lineOneDistance(vec2 pt) {\n            return abs(slopeOne * pt.x  -1.0 * pt.y + yIntOne) / denomOne;\n        }\n\n        // distance from line two (slopes up and to the right)\n        const float slopeTwo = -1.0;\n        const float yIntTwo = 0.0;\n        const float denomTwo = sqrt(slopeTwo * slopeTwo + 1.0);\n        float lineTwoDistance(vec2 pt) {\n            return abs(slopeTwo * pt.x  -1.0 * pt.y + yIntTwo) / denomTwo;\n        }\n\n        // method to get the pixel color associated with the first plaid layer\n        vec4 getLineOneTexel(vec2 pt, float vOffset) {\n            return getPlaidColor(\n                mod(lineOneDistance(vec2(pt.x, pt.y)), 1.0)\n            );\n        }\n\n        // method to get the pixel color associated with the second plaid layer\n        vec4 getLineTwoTexel(vec2 pt, float vOffset) {\n            return getPlaidColor(\n                mod(lineTwoDistance(vec2(pt.x, pt.y)), 1.0)\n            );\n        }\n\n        void main() {\n\n            #include <clipping_planes_fragment>\n\n            // we want to increase the number of plaid pattern repitions and provide a tweak so that the scroll offset makes the lines align when it hits 100%\n            vec2 vUvD = vec2(vUv.x * 30.0, vUv.y * 30.0);\n\n            // get the pixel color for each plaid direction\n            vec4 line_one_texel = getLineOneTexel(vUvD, verticalOffset);\n            vec4 line_two_texel = getLineTwoTexel(vUvD, verticalOffset);\n\n            // merge them with an average on the color but combine the opacities\n            vec4 diffuseColor = vec4(vec3((line_one_texel.r + line_two_texel.r)/2.0, (line_one_texel.g + line_two_texel.g)/2.0, (line_one_texel.b + line_two_texel.b)/2.0), (line_one_texel.a + line_two_texel.a));\n\n            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n            vec3 totalEmissiveRadiance = emissive;\n\n            #include <logdepthbuf_fragment>\n            #include <map_fragment>\n            #include <color_fragment>\n            #include <alphamap_fragment>\n            #include <alphatest_fragment>\n            #include <specularmap_fragment>\n\n            specularStrength = (0.1 * diffuseColor.r + 0.8 * diffuseColor.g + 0.1 * diffuseColor.b);\n\n            #include <normal_fragment>\n            #include <emissivemap_fragment>\n\n            // accumulation\n            #include <lights_phong_fragment>\n            #include <lights_template>\n\n            // modulation\n            #include <aomap_fragment>\n\n            vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n            #include <envmap_fragment>\n\n            gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n            #include <fog_fragment>\n            #include <premultiplied_alpha_fragment>\n            #include <dithering_fragment>\n        }\n\n    '].join()};var THREE=THREE||{};CanvasBackground=function(e){var o,r,l,p,d,s,n,t,i;_.extend(this,{},e);var a,c=d3.scaleLinear().domain([0,.5,1]).range([50,130,50]),f=d3.scaleLinear().domain([0,.5,1]).range([0,-Math.PI/8,-Math.PI/4]),u=function(){r.render(o,l)},m=function(){n=$(window).scrollTop(),a=n/(t-i),p.uniforms.verticalOffset.value=a,d.rotation.x=f(a),l.position.z=c(a),s.position.z=l.position.z,s.position.y=l.position.y,s.position.x=l.position.x,requestAnimationFrame(u)},v=function(){i=window.innerHeight,l.aspect=window.innerWidth/i,l.updateProjectionMatrix(),l.position.x=0,l.position.y=0,l.position.z=60,l.lookAt(new THREE.Vector3(0,0,0)),$(r.domElement).attr("style","position: fixed; top: 0; left: 0; width: 100%; height: 100%;"),r.setSize(window.innerWidth,window.innerHeight),t=$("body").height(),$("body").width(),m()};window.addEventListener("resize",v,!1),$(window).scroll(m),function(){o=new THREE.Scene,r=new THREE.WebGLRenderer({antialias:!0}),$("body").prepend(r.domElement).attr("style","position: relative;"),r.setClearColor(16777215,1),l=new THREE.PerspectiveCamera(5,window.innerWidth/window.innerHeight,.1,1e3);var e=new THREE.AmbientLight(3355443);o.add(e),s=new THREE.PointLight(4473924,1,225),o.add(s);var n=new THREE.PointLight(35071,1,60);n.position.set(30,12,12),o.add(n);var t=new THREE.PointLight(65416,1,60);t.position.set(-30,12,12),o.add(t);var i=new THREE.SphereGeometry(12,40,40),a=THREE.ShaderLib.plaid.uniforms;p=new THREE.ShaderMaterial({uniforms:a,defines:{},extensions:{derivatives:!0},vertexShader:THREE.ShaderLib.plaid.vertexShader,fragmentShader:THREE.ShaderLib.plaid.fragmentShader,fog:!1,lights:!0}),d=new THREE.Mesh(i,p),o.add(d)}(),v()};var _=(_=_||{})||{},CanvasBackground=CanvasBackground||{},main={start:function(){new CanvasBackground({canvas:$("canvas")});var t=function(e,n,t){t=t||$.noop,navigator.userAgent.match(/(iPod|iPhone|iPad|Android)/)?$("body").animate({scrollTop:e},n,t):$("html,body").animate({scrollTop:e},n,t)};$(".back-to-top").click(function(){t(0,0)}),$(".nav-button").click(function(){var e=$(this),n=$(e.attr("data-target"));t(n.offset().top,900,function(){n.attr("tabindex","-1"),n.focus()})}),$("[data-mastery-percent]").each(function(){var e=$(this),n=e.attr("data-mastery-percent"),t=$('<span class="sr-only">'+n+" percent proficient</span>");e.append(t),e.attr("style","width:"+n+"%")}),new Waypoint({element:$(".skill-set-group-row"),offset:"50%",handler:function(e,n,t){$(this.element).addClass("show-groups")}}),new Waypoint({element:$(".section-profile"),handler:function(e){"down"===e?$(".back-to-top").addClass("back-to-top-active"):$(".back-to-top").removeClass("back-to-top-active")}})}};